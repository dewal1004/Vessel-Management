OBJECT Table 50014 Monthly Variables Lines.
{
  OBJECT-PROPERTIES
  {
    Date=20030317D;
    Time=124455T;
    Modified=true;
    Version List=CBU Ver. 1.00,LOAN1.0;
  }
  PROPERTIES
  {
    OnInsert=BEGIN
               GetParam();
             END;

    OnModify=BEGIN
               {���������������������������������������������������������������������������Ŀ
               � This trigger is called if any of the fields in "KI03b P.Roll Entry" is     �
               � not equal to the corresponding field in "xKI03b P.Roll Entry"              �
               �����������������������������������������������������������������������������}
               GetParam();

               if (Rec.Amount <> xRec.Amount) or ("Loan ID"<>'') then
               begin
                  Mark( true);
                 { If this new entry contributes in computing another, then compute that value
                   for that computed entry and insert it appropriately}
                 CalcCompute (Rec, Rec.Amount, false, "E/D Code");
               {BDC}

                 { If this new entry is a contributory factor for the value of another line,
                   then compute that other line's value and insert it appropriately }
                 CalcFactor1 (Rec);

                 { The two functions above have used this line to change others }
                 ChangeOthers := false;

                 { Go through all the lines and change where necessary }
                 ChangeAllOver (Rec, false);

                 { Reset the ChangeOthers flag in all lines }
               {    ResetChangeFlags (Rec);}

               {BDC
                  MARK( FALSE);}

               end;
             END;

    OnDelete=BEGIN
                ProllHeader.Get( "Payroll Period", "Employee No");
                if ProllHeader."Closed?" then
                 Error ('Entries for Employee %1/ in Period %2/ are closed. '+
                        'Nothing can be deleted', "Employee No", "Payroll Period");

               { Go through all the lines and make any appropriate Changes }
               ChangeOthers := false;
               ChangeDueToDelete(Rec);

               { Set the 'Change' flags to false in all the lines }
               ResetChangeFlags(Rec);
             END;

    DrillDownPageID="Monthly Variables Lines.";
  }
  FIELDS
  {
    { 1   ;   ;Payroll Period      ;Code10        ;TableRelation="Payroll-Periods.";
                                                   OnValidate=BEGIN
                                                                GetParam();
                                                              END;

                                                   Editable=true }
    { 2   ;   ;Employee No         ;Code20        ;TableRelation=Employee;
                                                   OnValidate=BEGIN
                                                                GetParam();
                                                              END;

                                                   NotBlank=true;
                                                   Editable=true }
    { 3   ;   ;E/D Code            ;Code20        ;TableRelation="Payroll-E/D Codes."."E/D Code" WHERE ("Monthly Variable"=CONST(true));
                                                   OnValidate=BEGIN
                                                                GetParam();

                                                                { If Period+Employee has already been closed then stop edit }
                                                                if CheckClosed  then
                                                                  Error ('Entries for Employee %1 for period %2 '+
                                                                         'have already been closed.', "Employee No", "Payroll Period");

                                                                 "E/DFileRec".Get( "E/D Code");
                                                                "Payslip Text" := "E/DFileRec"."Payslip Text";

                                                                { Transfer Units, Rate, Payslip Group ID. and Pos in Payslip Group }
                                                                begin
                                                                  "Payslip Group ID" := "E/DFileRec"."Payslip Group ID";
                                                                  "Pos. In Payslip Grp." := "E/DFileRec"."Pos. In Payslip Grp.";
                                                                  "Payslip appearance" := "E/DFileRec"."Payslip appearance";
                                                                  Units := "E/DFileRec".Units;
                                                                  Rate := "E/DFileRec".Rate;
                                                                  "Overline Column" := "E/DFileRec"."Overline Column";
                                                                  "Underline Amount" := "E/DFileRec"."Underline Amount";
                                                                  "Variable Unit" := "E/DFileRec"."Variable Unit";
                                                                  "Monthly Variable" := "E/DFileRec"."Monthly Variable";
                                                                end;

                                                                { Calculate the amount if neither quantities nor yes flag are required}
                                                                if ("Variable Unit" = 0) and not ("E/DFileRec"."Yes/No Req.?") then
                                                                begin

                                                                  Amount := CalcAmount ("E/DFileRec", Rec, Amount, "E/D Code");
                                                                  if Rec.Amount <> xRec.Amount then
                                                                  begin
                                                                    { Change the entries that are computed using this new amount }
                                                                    CalcCompute (Rec, Amount, true, "E/D Code");
                                                                {BDC}

                                                                    { If this new entry contributes to the value of another line
                                                                      then compute that other line's value and insert it appropriately}
                                                                    CalcFactor1 (Rec);

                                                                    { Go through all the lines and change where necessary }
                                                                    ChangeAllOver (Rec, false);

                                                                    { Reset the ChangeOthers flag in all lines }
                                                                    ResetChangeFlags (Rec);
                                                                  end
                                                                end;

                                                                { Transfer from Booking Group Lines }
                                                                 EmployeeRec.Get("Employee No");
                                                                if  BookGrLinesRec.Get( EmployeeRec."Posting Group","E/D Code") then
                                                                begin
                                                                  begin
                                                                    "Debit Account" := BookGrLinesRec."Debit Account No.";
                                                                    "Credit Account" := BookGrLinesRec."Credit Account No.";
                                                                    "Debit Acc. Type" := BookGrLinesRec."Debit Acc. Type";
                                                                    "Credit Acc. Type" := BookGrLinesRec."Credit Acc. Type";
                                                                {BDC
                                                                    "Department Code" := BookGrLinesRec.Department;
                                                                    "Project Code" := BookGrLinesRec.Project;
                                                                }
                                                                  end;
                                                                {BDC
                                                                  IF NOT BookGrLinesRec."Transfer Department" THEN
                                                                    "Department Code" := ''
                                                                  ELSE
                                                                  IF "Department Code" = '' THEN
                                                                      "Department Code" := EmployeeRec.Department;

                                                                  IF NOT BookGrLinesRec."Transfer Project" THEN
                                                                    "Project Code" := ''
                                                                  ELSE
                                                                  IF "Project Code" = '' THEN
                                                                    "Project Code" := EmployeeRec.Project;

                                                                  IF BookGrLinesRec."Debit Acc. Type" = 1 THEN
                                                                    IF "Debit Account" = '' THEN
                                                                      IF EmployeeRec."Customer Number" <> '' THEN
                                                                        "Debit Account" := EmployeeRec."Customer Number" ;

                                                                  IF BookGrLinesRec."Credit Acc. Type" = 1 THEN
                                                                    IF "Credit Account" = '' THEN
                                                                      IF EmployeeRec."Customer Number"  <> '' THEN
                                                                        "Credit Account" := EmployeeRec."Customer Number" ;
                                                                }

                                                                 if BookGrLinesRec."Transfer Department" then
                                                                    "Global Dimension 1 Code" := EmployeeRec."Global Dimension 1 Code";
                                                                  if BookGrLinesRec."Transfer Business Units" then
                                                                    "Global Dimension 2 Code" := EmployeeRec."Global Dimension 2 Code";
                                                                end;
                                                              END;

                                                   OnLookup=BEGIN
                                                              Clear(EDPage);
                                                              NewEDRec.FilterGroup(7);
                                                              NewEDRec.SetRange(NewEDRec."Monthly Variable",true);
                                                              NewEDRec.FilterGroup(0);

                                                              EDPage.SetTableView(NewEDRec);
                                                              EDPage.SetRecord(NewEDRec);
                                                              EDPage.Editable(false);
                                                              EDPage.LookupMode(true);

                                                              if EDPage.RunModal = ACTION::LookupOK then
                                                                EDPage.GetRecord(NewEDRec);

                                                              if NewEDRec."E/D Code"<>'' then Validate("E/D Code",NewEDRec."E/D Code");
                                                            END;

                                                   NotBlank=true }
    { 4   ;   ;Units               ;Text10        ;Editable=false }
    { 5   ;   ;Rate                ;Decimal       ;OnValidate=BEGIN
                                                                GetParam();

                                                                { If Period+Employee has already been closed then stop edit }
                                                                if CheckClosed  then
                                                                  Error ('Entries for Employee %1 for period %2 '+
                                                                         'have already been closed.', "Employee No", "Payroll Period");

                                                                if ("Variable Unit" = 0) then
                                                                  { User cannot edit the rate if the E/D code has no units}
                                                                  Rec.Rate := xRec.Rate
                                                                else
                                                                begin
                                                                  Amount := Quantity * Rate;

                                                                  {Check for rounding, Maximum and minimum }
                                                                   "E/DFileRec".Get( "E/D Code");
                                                                  Amount := ChkRoundMaxMin ("E/DFileRec", Amount);

                                                                end
                                                              END;

                                                   DecimalPlaces=0:5;
                                                   Editable=false }
    { 6   ;   ;Quantity            ;Decimal       ;OnValidate=BEGIN
                                                                GetParam();

                                                                {If Period+Employee has already been closed then stop edit}
                                                                if CheckClosed  then
                                                                   Error ('Entries for Employee %1 for period %2 '+
                                                                         'have already been closed.', "Employee No", "Payroll Period");

                                                                if ("Variable Unit" = 0) then
                                                                   {User cannot enter quantity if the E/D code has no units}
                                                                   Rec.Quantity := xRec.Quantity
                                                                else
                                                                  begin
                                                                      Amount := Quantity * Rate;
                                                                    if ("Variable Unit" = "Variable Unit"::Hours) then
                                                                      Amount := Round((BasicPay * Rate  * Quantity)/(HrsInDay*DaysInMonth));

                                                                    if ("Variable Unit" = "Variable Unit"::Days) then
                                                                      Amount := Round((BasicPay * Rate  * Quantity)/DaysInMonth);

                                                                    Amount := Round((BasicPay * Rate  * Quantity)/(PaySetup."Total Monthly Hours"));
                                                                    {Check for rounding, Maximum and minimum}
                                                                    "E/DFileRec".Get( "E/D Code");
                                                                    Amount := ChkRoundMaxMin ("E/DFileRec", Amount);
                                                                  end
                                                              END;

                                                   DecimalPlaces=0:5 }
    { 7   ;   ;Flag                ;Boolean       ;OnValidate=BEGIN
                                                                { If Period+Employee has already been closed then stop edit }
                                                                if CheckClosed  then
                                                                  Error ('Entries for Employee %1 for period %2 '+
                                                                         'have already been closed.', "Employee No", "Payroll Period");

                                                                 "E/DFileRec".Get("E/D Code");
                                                                if not ("E/DFileRec"."Yes/No Req.?") then
                                                                  Flag := false
                                                                else
                                                                  Amount := CalcAmount ("E/DFileRec", Rec, Amount, "E/D Code");
                                                              END;
                                                               }
    { 8   ;   ;Amount              ;Decimal       ;OnValidate=BEGIN
                                                                { If Period+Employee has already been closed then stop edit }
                                                                if CheckClosed  then
                                                                  Error ('Entries for Employee %1 for period %2 '+
                                                                         'have already been closed.', "Employee No", "Payroll Period");

                                                                 "E/DFileRec".Get( "E/D Code");
                                                                if not ("E/DFileRec"."Edit Amount?") then
                                                                  Rec.Amount := xRec.Amount
                                                                else
                                                                  {Check for rounding, Maximum and minimum }
                                                                  Amount := ChkRoundMaxMin ("E/DFileRec", Amount);
                                                              END;

                                                   DecimalPlaces=0:2 }
    { 9   ;   ;Debit Account       ;Code20        ;TableRelation=IF ("Debit Acc. Type"=CONST(Finance)) "G/L Account"
                                                                 ELSE IF ("Debit Acc. Type"=CONST(Customer)) Customer;
                                                   OnValidate=BEGIN
                                                                if "Debit Account" <> '' then
                                                                  case "Debit Acc. Type" of
                                                                    0:  FinanceAccRec.Get( "Debit Account");
                                                                    1:  CustomerAccRec.Get( "Debit Account");
                                                                    2:  SupplierAccRec.Get( "Debit Account");
                                                                  end;
                                                              END;
                                                               }
    { 10  ;   ;Credit Account      ;Code20        ;TableRelation=IF ("Credit Acc. Type"=CONST(Finance)) "G/L Account"
                                                                 ELSE IF ("Credit Acc. Type"=CONST(Customer)) Customer;
                                                   OnValidate=BEGIN
                                                                if "Credit Account" <> '' then
                                                                  case "Credit Acc. Type" of
                                                                    0:  FinanceAccRec.Get(  "Credit Account");
                                                                    1:  CustomerAccRec.Get( "Credit Account");
                                                                    2:  SupplierAccRec.Get( "Credit Account");
                                                                  end;
                                                              END;
                                                               }
    { 11  ;   ;Global Dimension 1 Code;Code10     ;TableRelation="Dimension Value".Code WHERE ("Global Dimension No."=CONST(1));
                                                   CaptionClass='1,1,1' }
    { 12  ;   ;Global Dimension 2 Code;Code10     ;TableRelation="Dimension Value".Code WHERE ("Global Dimension No."=CONST(2));
                                                   CaptionClass='1,1,2' }
    { 13  ;   ;AmountToBook        ;Decimal       ;DecimalPlaces=0:5;
                                                   Editable=false }
    { 14  ;   ;Payslip Group ID    ;Option        ;OptionString=,"GROSS PAY","TAXABLE PAY","TAX CHARGED","TAX DEDUCTED","TOTAL DEDUCTIONS","NET PAY DUE" }
    { 15  ;   ;Pos. In Payslip Grp.;Integer        }
    { 16  ;   ;Payslip appearance  ;Option        ;OptionString="Non-zero & Code","Always & Code","Always & Text","Non-zero & Text","Does not appear",Heading }
    { 17  ;   ;Debit Acc. Type     ;Option        ;OptionString=Finance,Customer,Supplier }
    { 18  ;   ;Credit Acc. Type    ;Option        ;OptionString=Finance,Customer,Supplier }
    { 19  ;   ;ChangeOthers        ;Boolean       ;InitValue=false;
                                                   Editable=false }
    { 20  ;   ;HasBeenChanged      ;Boolean       ;InitValue=false;
                                                   Editable=false }
    { 21  ;   ;ChangeCounter       ;Integer       ;InitValue=0;
                                                   Editable=false }
    { 22  ;   ;Payslip Column      ;Option        ;InitValue=2;
                                                   OptionString="1","2","3" }
    { 23  ;   ;S. Report appearance;Option        ;OptionString="Non-zero & Code","Always & Code","Always & Text","Non-zero & Text","Does not appear",Heading }
    { 24  ;   ;Overline Column     ;Option        ;InitValue=None;
                                                   OptionString=None,"1","2","3","1-2","2-3","1-3" }
    { 25  ;   ;Underline Amount    ;Option        ;InitValue=None;
                                                   OptionString=None,Underline,"Double Underline" }
    { 26  ;   ;Loan ID             ;Code10        ;TableRelation="Loan." }
    { 27  ;   ;Payslip Print Column;Option        ;OptionString=" ",Postive,Negative,"Total Earning","Total Deduction","Net Earning" }
    { 28  ;   ;Payslip Text        ;Text100        }
    { 29  ;   ;Variable Unit       ;Option        ;OnValidate=BEGIN
                                                                if not "Monthly Variable" then "Variable Unit" := 0;
                                                              END;

                                                   OptionCaptionML=ENU=" ,Hours,Days";
                                                   OptionString=" ",Hours,Days;
                                                   Editable=true }
    { 30  ;   ;Monthly Variable    ;Boolean       ;Description=Added for Overtime;
                                                   Editable=false }
  }
  KEYS
  {
    {    ;"Payroll Period","Employee No","E/D Code";
                                                   SumIndexFields=Amount;
                                                   Clustered=true }
    {    ;"Payroll Period","Global Dimension 1 Code","Global Dimension 2 Code","Debit Acc. Type","Debit Account","Credit Acc. Type","Credit Account","Loan ID";
                                                   KeyGroups=MI-PROLL }
    {    ;"Payroll Period","Employee No","Payslip Group ID","Pos. In Payslip Grp.";
                                                   KeyGroups=MI-PROLL }
    {    ;"E/D Code","Employee No","Payroll Period";
                                                   KeyGroups=MI-PROLL }
    {    ;"Employee No","Payroll Period"          ;SumIndexFields=Quantity;
                                                   KeyGroups=MI-PROLL }
    {    ;"Payroll Period","Employee No","Global Dimension 1 Code","Global Dimension 2 Code" }
    {    ;"Global Dimension 2 Code","Global Dimension 1 Code" }
    {    ;"Payslip Print Column","E/D Code"        }
  }
  FIELDGROUPS
  {
  }
  CODE
  {
    VAR
      "E/DFileRec"@1000000000 : Record "Payroll-E/D Codes.";
      ConstEDFileRec@1000000001 : Record "Payroll-E/D Codes.";
      ProllHeader@1000000002 : Record "Monthly Variables Header.";
      ProllRecStore@1000000003 : Record "Monthly Variables Lines.";
      ProllFactorRec@1000000004 : Record "Monthly Variables Lines.";
      ProllEntryRec@1000000005 : Record "Monthly Variables Lines.";
      ChangeOthersRec@1000000006 : Record "Monthly Variables Lines.";
      LookHeaderRec@1000000007 : Record "Payroll-Lookup Header.";
      LookLinesRec@1000000008 : Record "Payroll-Lookup Lines.";
      BackOneRec@1000000009 : Integer;
      ReturnAmount@1000000010 : Decimal;
      PrevLookRec@1000000011 : Record "Payroll-Lookup Lines.";
      InputAmount@1000000012 : Decimal;
      ComputedTotal@1000000013 : Decimal;
      AmountToAdd@1000000014 : Decimal;
      FactorRecAmount@1000000015 : Decimal;
      AmtToAdd@1000000016 : Decimal;
      EmployeeRec@1000000017 : Record Employee;
      BookGrLinesRec@1000000018 : Record "Payroll-Posting Group Line.";
      RoundPrec@1000000019 : Decimal;
      RoundDir@1000000020 : Text[1];
      IsComputed@1000000021 : Boolean;
      FinanceAccRec@1000000022 : Record "G/L Account";
      CustomerAccRec@1000000023 : Record Customer;
      SupplierAccRec@1000000024 : Record Vendor;
      MaxChangeCount@1000000025 : Integer;
      PayLines2@1000000026 : Record "Monthly Variables Lines.";
      CurYear@1000000027 : Integer;
      PeriodRec@1000000028 : Record "Payroll-Periods.";
      PerStart@1000000029 : Date;
      Per1@1000000030 : Code[10];
      YearStart@1000000031 : Date;
      TaxableED@1000000032 : Code[10];
      TaxfreeED@1000000033 : Code[10];
      PaySetup@1000000034 : Record "ASL Payroll Setup";
      HrsInDay@1000000035 : Integer;
      DaysInMonth@1000000036 : Integer;
      BasicPay@1000000037 : Decimal;
      NewEDRec@1000000038 : Record "Payroll-E/D Codes.";
      EDPage@1000 : Page "E/D Codes.";

    [LineStart(117033)]
    PROCEDURE SpecialRelation@100("FieldNo."@1000000000 : Integer);
    BEGIN
      {���������������������������������������������������������������������������Ŀ
      � Special Relations code for the field, E/D Code                             �
      �����������������������������������������������������������������������������}

      { Force NO-EDIT of field already has a value or if Employee payroll details
        for the period are already closed}
      if "E/D Code" <> '' then
        exit;

      { If Period+Employee has already been closed then stop edit }
      if CheckClosed  then
        Error ('Entries for Employee %1 for period %2 '+
               'have already been closed.', "Employee No", "Payroll Period");
    END;

    [LineStart(117048)]
    PROCEDURE CalcAmount@1(EDFileRec@1000000000 : Record "Payroll-E/D Codes.";EntryLineRec@1000000001 : Record "Monthly Variables Lines.";EntryLineAmount@1000000002 : Decimal;EDCode@1000000003 : Code[20]) : Decimal;
    BEGIN
      {���������������������������������������������������������������������������Ŀ
      � Calculate the amount based on Factor Of and Percentage fields in the file  �
      � E/D file, alternatively calculate if the current line is computed by others�
      �  Parameters:                                                               �
      �    EDFileRec    : EDFile Record for the E/D Code of the current entry line �
      �    EntryLineRec : The current entry line record                            �
      �    EntryLineAmount: The amount in the current entry line. Note this        �
      �    parameter is important if this trigger is called from the SAVE trigger  �
      �����������������������������������������������������������������������������}

      { If NO is in the flag field return amount to 0}
      if (EDFileRec."Yes/No Req.?") and not (EntryLineRec.Flag) then
        exit (0);

      { If Factor Of is Nil then do not change then check if amount is computed by
        others}

      if EDFileRec."Factor Of" = '' then
        if not AmountIsComputed (ReturnAmount, EntryLineRec, EDFileRec,
                                 EntryLineAmount, EDCode) then
          {BDC}
      if EDFileRec."Factor Of" = '' then
          exit (EntryLineRec.Amount)
        else
        begin
          {Check for rounding, Maximum and minimum }
          ReturnAmount := ChkRoundMaxMin (EDFileRec, ReturnAmount);
          exit (ReturnAmount);
        end;
      { Get the record from the current file based on Factor Of }
      if not  ProllFactorRec.Get( EntryLineRec."Payroll Period",
                       EntryLineRec."Employee No", EDFileRec."Factor Of") then
        exit (EntryLineRec.Amount)
      else
        { If this 'Factor of' entry record is marked then this trigger was called
          from this 'Fator of' record, therefore ensure the amount to be used is
          the updated amount}
        {BDC
        IF  ProllFactorRec.MARK THEN
        }
        if  ProllFactorRec."E/D Code" = EDCode then
          ProllFactorRec.Amount := EntryLineAmount;

      { Calculate the amount based on values in Table Look Up or Percentage fields
        of E/D file }
      if EDFileRec."Table Look Up" = '' then
        begin
          ReturnAmount := (ProllFactorRec.Amount * EDFileRec.Percentage) / 100;
          Message('Factor Percentage: ' + Format(EDFileRec.Percentage));
        end
      else { Extract relevant amount from Table Look Up }

        if not  LookHeaderRec.Get( EDFileRec."Table Look Up") then
        begin
          Message ('Table Lookup Not Registered Yet');
          exit (EntryLineRec.Amount)
        end
        else begin { Table lookup exists}

          { Filter Lookupline records to those of current Table Id Only}
          LookLinesRec.TableId := EDFileRec."Table Look Up";
           LookLinesRec.SetRange(TableId, EDFileRec."Table Look Up");

          { Depending on whether input parameter is code or numeric, set dbSETRANGE
            appropraitely and initialise the record to use as a parameter to
            dbFINDREC }
          case LookHeaderRec.Type of
          0,2:
            begin
              { Lookup table is searched with numeric variables }
              if ProllFactorRec.Amount > -1 then begin
                LookLinesRec."Lower Code" := '';
                InputAmount := ProllFactorRec.Amount * LookHeaderRec."Input Factor";
                LookLinesRec."Lower Amount" := InputAmount;
                 LookLinesRec.SetRange("Lower Code",'');
              end
              else
                exit (LookHeaderRec."Min. Extract Amount")
            end;
          else  {Lookup table is searched with variables of type code}
            begin
              LookLinesRec."Lower Amount" := 0;
              LookLinesRec."Lower Code" := EDFileRec."E/D Code";
               LookLinesRec.SetRange("Upper Amount",0);
               LookLinesRec.SetRange("Lower Amount",0);
            end
          end; { Case}

          case LookHeaderRec.Type of
          0,1: begin
             { Extract amount as follows; First find line where Lower Amount or
               lower code is just greater than the Factor Amount then move one
               line back.}

            if  LookLinesRec.Find( '=') then
              ReturnAmount := LookLinesRec."Extract Amount"
            else
            if  LookLinesRec.Find( '>') then begin
              BackOneRec :=  LookLinesRec.Next( -1);
              ReturnAmount := LookLinesRec."Extract Amount";
            end
            else
              if LookHeaderRec.Type = 0 then begin
              {'Factor' Amount is > than the table's greatest "Lower amount"}
                if  LookLinesRec.Find( '+') then
                  ReturnAmount := LookLinesRec."Extract Amount";
              end
              else
                exit (EntryLineRec.Amount);
            end;

          2: {  Extract amount from tax table}
            ReturnAmount := (CalcTaxAmt (LookLinesRec, InputAmount)) *
                            LookHeaderRec."Output Factor";
          end; { Case }

          { Adjust the amount as per the maximum/minimum in the LookupHeader}
          if (LookHeaderRec."Max. Extract Amount" <> 0) and
             (ReturnAmount > LookHeaderRec."Max. Extract Amount") then
            ReturnAmount := LookHeaderRec."Max. Extract Amount"
          else
            if (ReturnAmount < LookHeaderRec."Min. Extract Amount") then
              ReturnAmount := LookHeaderRec."Min. Extract Amount";

          { Check for rounding }
          if LookHeaderRec."Rounding Precision" = 0 then
            RoundPrec := 0.01
          else
            RoundPrec := LookHeaderRec."Rounding Precision";
          case LookHeaderRec."Rounding Direction" of
            1: RoundDir := '>';
            2: RoundDir := '<';
            else RoundDir := '=';
          end;
          ReturnAmount := Round (ReturnAmount, RoundPrec, RoundDir);

           LookLinesRec.Reset
        end;

      {Check for rounding, Maximum and minimum }
      ReturnAmount := ChkRoundMaxMin (EDFileRec, ReturnAmount);

      exit (ReturnAmount);
    END;

    [LineStart(117193)]
    PROCEDURE CheckClosed@2() : Boolean;
    BEGIN
      {���������������������������������������������������������������������������Ŀ
      � Return the value of ProllHeader."Closed?" for this Period + Employee       �
      �����������������������������������������������������������������������������}
      ProllHeader.Get("Payroll Period","Employee No");
      exit (ProllHeader."Closed?");
    END;

    [LineStart(117200)]
    PROCEDURE CalcTaxAmt@3(VAR LDetailsRec@1000000000 : Record "Payroll-Lookup Lines.";TaxTableInput@1000000001 : Decimal) : Decimal;
    BEGIN
      {���������������������������������������������������������������������������Ŀ
      � Returns the tax figure from a table lookup of type Tax                     �
      �����������������������������������������������������������������������������}
      { Parameters:
        by Referrence : The current Lookup detail table record = LDetailsRec.
                        NB: By referrence so that all delimitations, sortings etc
                            are still in effect.
        by value      : The amount to be taxed = TaxTableInput
      }

      { Copy all current filters of LookUpRec }
      PrevLookRec := LDetailsRec;
      { COPYFILTERS(LDetailsRec );          }
      {BDC
      PrevLookRec.COPYFILTERS(LDetailsRec);
      }
      if  LDetailsRec.Find( '=') then
        {Record found where Lower Amount is equal to TaxTableInput}
        if  PrevLookRec.Next(-1) = 0 then
          ReturnAmount := (TaxTableInput * LDetailsRec."Tax Rate %")/100
        else
          { Call function to get the tax amount from the graduated tax table.}
          ReturnAmount := CalcGraduated (LDetailsRec, TaxTableInput)
      else
      if  LDetailsRec.Find( '>') then
        {Record found where Lower Amount is just larger than TaxTableInput.
         Therefore TaxableInput should be in previus range (= record)}
        if  LDetailsRec.Next(-1) = 0 then
          { The lowest taxable amount is larger than the input amount }
          ReturnAmount := 0
        else
          ReturnAmount := CalcGraduated (LDetailsRec, TaxTableInput)
      else
        {TaxableInput is larger than the table's greatest lower amount}
        if  LDetailsRec.Next(-1) = 0 then
          ReturnAmount := (TaxTableInput * LDetailsRec."Tax Rate %")/100
        else
          { Call function to get the tax amount from the graduated tax table.}
          ReturnAmount := CalcGraduated (LDetailsRec, TaxTableInput);

      exit (ReturnAmount);
    END;

    [LineStart(117243)]
    PROCEDURE CalcGraduated@4(VAR WantedLookRec@1000000000 : Record "Payroll-Lookup Lines.";InputToTable@1000000001 : Decimal) : Decimal;
    BEGIN
      {��������������������������������������������������������������������������Ŀ
      � Returns the tax amount from the graduated tax table.                      �
      � Parameters                                                                �
      � by reference : The Table Lookup record within which the Taxable amount    �
      �                falls = WantedLookRec                                      �
      �                NB: By referrence so that all delimitations, sortings etc  �
      �                    are still in effect.                                   �
      � by value     : The amount to be taxed = InputToTable                      �
      ����������������������������������������������������������������������������}

      { Create a copy of the valid Look Up table Record }
      PrevLookRec :=  WantedLookRec;
       {BDC
       COPYFILTERS(WantedLookRec );
      }
      if  PrevLookRec.Next(-1) = 0 then
       ReturnAmount := (InputToTable * WantedLookRec."Tax Rate %")/100
      else
      begin
        { Compute tax for the amount of money that is within the range of the
          Wanted Look Up Record then add the Cumulative Tax Payable amount from
          the previous Look Up record}

         ReturnAmount :=  (InputToTable - PrevLookRec."Upper Amount");
         ReturnAmount :=  (ReturnAmount * WantedLookRec."Tax Rate %")/100;
         ReturnAmount :=  ReturnAmount + PrevLookRec."Cum. Tax Payable";
      end;
      exit (ReturnAmount);
    END;

    [LineStart(117273)]
    PROCEDURE CalcCompute@5(EntryRecParam@1000000000 : Record "Monthly Variables Lines.";AmountInLine@1000000001 : Decimal;"CalledFromEdCode?"@1000000002 : Boolean;EDCode@1000000003 : Code[20]);
    BEGIN
      {��������������������������������������������������������������������������Ŀ
      � Depending on the value of the Compute field for the E/D File record that  �
      � corresponds to the current P.Roll Entry Line record                       �
      � Parameters :                                                              �
      �   EntryRecParam           : Current entry line                            �
      �   Amount in current line  : The figure in the amount field in this line   �
      �   "CalledFromEdCode?"     : True if the trigger code was called from the  �
      �                            "E/D Code" field                               �
      ����������������������������������������������������������������������������}

       ConstEDFileRec.Get( EntryRecParam."E/D Code");
      "E/DFileRec" := ConstEDFileRec;
      if "E/DFileRec".Compute = '' then
        exit;

       ProllEntryRec.Init;
       ProllEntryRec.SetRange("Payroll Period", EntryRecParam."Payroll Period");
       ProllEntryRec.SetRange("Employee No", EntryRecParam."Employee No");

      { If the entry line to be computed does not exist then EXIT }
      ProllEntryRec := EntryRecParam;
      ProllEntryRec."E/D Code" := ConstEDFileRec.Compute;
      if not  ProllEntryRec.Find( '=') then
        exit;

      { Initialise the variable to store the computed total. Note if the trigger
        code was called from the "E/D Code" field then that record is a new one.
        This implies that a search of the records in the file will not find this
        new record. Therefore for it's amount to be used in the computation
        we initialise the computed total to that amount}
      if "CalledFromEdCode?" then
      begin
        if "E/DFileRec"."Add/Subtract" = 2 then
          { Subtract }
          ComputedTotal := - AmountInLine
        else
          { Add }
          ComputedTotal := AmountInLine
      end
      else
       ComputedTotal := 0;

      {Get first record in P.Roll Entry file for this Period/Employee combination}
      ProllEntryRec := EntryRecParam;
      ProllEntryRec."E/D Code" := '';
       ProllEntryRec.Find( '>');

      { Go through all the entry lines for this Period/Employee record and sum up
        all those that contribute to the E/D specified in the Compute field for
        the current entry line }
      repeat
      begin
        {BDC
          IF  ProllEntryRec.MARK THEN
          }
           if  EDCode = ProllEntryRec."E/D Code" then
          { We are at the record where the function was called from }
          AmountToAdd := AmountInLine
        else
          AmountToAdd := ProllEntryRec.Amount;

         "E/DFileRec".Get( ProllEntryRec."E/D Code");
        if "E/DFileRec".Compute = ConstEDFileRec.Compute then
          if "E/DFileRec"."Add/Subtract" = 2 then
            { Subtract }
            ComputedTotal := ComputedTotal - AmountToAdd
          else
            { Add }
            ComputedTotal := ComputedTotal + AmountToAdd;
      end
      until ( ProllEntryRec.Next(1) = 0);

      { Move the computed amount to the line whose E/D Code is the one that has
        just been calculated.}
       ProllEntryRec.Init;
      ProllEntryRec."E/D Code" := ConstEDFileRec.Compute;
       "E/DFileRec".Get( ConstEDFileRec.Compute);
      {FTN No Need
      dbTRANSFERFIELDS ("E/DFileRec", ProllEntryRec);
      }

      {Check for rounding, Maximum and minimum }
      ComputedTotal := ChkRoundMaxMin ("E/DFileRec", ComputedTotal);

      {ProllEntryRec.Amount := ComputedTotal;
      ProllRecStore := ProllEntryRec;}
       ProllEntryRec.LockTable( false);
      if  ProllEntryRec.Find( '=') then
      begin
        {ProllRecStore.ChangeOthers := TRUE;
        ProllRecStore.HasBeenChanged := TRUE;
        dbMODIFYREC (ProllRecStore);}
        ProllEntryRec.Amount := ComputedTotal;
        ProllEntryRec.ChangeOthers := true;
        ProllEntryRec.HasBeenChanged := true;
         ProllEntryRec.Modify;
      end;
      Commit;

       ProllEntryRec.SetRange("Payroll Period");
       ProllEntryRec.SetRange("Employee No");
    END;

    [LineStart(117376)]
    PROCEDURE CalcFactor1@7(CurrentEntryLine@1000000000 : Record "Monthly Variables Lines.");
    BEGIN
      {���������������������������������������������������������������������������Ŀ
      � If an entry is a contributory factor for the value of another line, then   �
      � compute that other line's value and insert it appropriately                �
      � Parameters :                                                               �
      �   CurrentEntryLine        : Current entry line                             �
      �����������������������������������������������������������������������������}

      { Get first record in Entry Lines file for this Employee/Period }
      ProllEntryRec := CurrentEntryLine;
       ProllEntryRec.Init;
       ProllEntryRec.SetRange("Employee No", ProllEntryRec."Employee No");
       ProllEntryRec.SetRange("Payroll Period", ProllEntryRec."Payroll Period");
      ProllEntryRec."E/D Code" := '';
       ProllEntryRec.Find( '>');

      { Go through all the entry lines for this Period/Employee record and where
        the current entry line's value is a factor, calculate that amount. }
      repeat

         "E/DFileRec".Get( ProllEntryRec."E/D Code");

        if "E/DFileRec"."Factor Of" = CurrentEntryLine."E/D Code" then
        begin

          FactorRecAmount := ProllEntryRec.Amount;
          ProllEntryRec.Amount := "CalcFactor1.1" (CurrentEntryLine,
                                                     ProllEntryRec,"E/DFileRec");
          {The new entry in this line should now be used to Compute another and
          also entries where it is a Factor, therefore set ChangeOthers to True}
          if FactorRecAmount <> ProllEntryRec.Amount then
          begin
            ProllEntryRec.ChangeOthers := true;
             ProllEntryRec.Modify;
          end
        end;

      until ( ProllEntryRec.Next(1) = 0);
      Commit;
    END;

    [LineStart(117416)]
    PROCEDURE "CalcFactor1.1"@9(CurrLineRec@1000000000 : Record "Monthly Variables Lines.";LineToChangeRec@1000000001 : Record "Monthly Variables Lines.";EDFileRec@1000000002 : Record "Payroll-E/D Codes.") : Decimal;
    BEGIN
      {���������������������������������������������������������������������������Ŀ
      � Calculate the amount based on Factor Of and Percentage fields of the file  �
      � E/D file,
      �  Parameters:                                                               �
      �    CurrLineRec    : The current entry line record                          �
      �    LineToChangeRec: The entry line to be changed.
      �    EDFileRec      : EDFile Record for the E/D Code of LineToChangeRec      �
      �����������������������������������������������������������������������������}

      { If NO is in the flag field return amount to 0 }
      if (EDFileRec."Yes/No Req.?") and not (LineToChangeRec.Flag) then
        exit (0);

      { Calculate the amount based on values in Table Look Up or Percentage fields
        of E/D file }
      if EDFileRec."Table Look Up" = '' then
        ReturnAmount := (CurrLineRec.Amount * EDFileRec.Percentage) / 100
      else { Extract relevant amount from Table Look Up }

        if not  LookHeaderRec.Get( EDFileRec."Table Look Up") then
        begin
          Message ('Table Lookup Not Registered Yet');
          exit (LineToChangeRec.Amount)
        end
        else begin { Table lookup exists}

          { Filter Lookupline records to those of current Table Id Only}
          LookLinesRec.TableId := EDFileRec."Table Look Up";
           LookLinesRec.SetRange(TableId, EDFileRec."Table Look Up");

          { Depending on whether input parameter is code or numeric, set dbSETRANGE
            appropraitely and initialise the record to use as a parameter to
            dbFINDREC }
          case LookHeaderRec.Type of
          0,2:
            begin
              { Lookup table is searched with numeric variables }
              if CurrLineRec.Amount > -1 then begin
                LookLinesRec."Lower Code" := '';
                LookLinesRec."Lower Amount" := CurrLineRec.Amount *
                                               LookHeaderRec."Input Factor";
                 LookLinesRec.SetRange("Lower Code",'');
              end
              else
                exit (LookHeaderRec."Min. Extract Amount")
            end;
          else  {Lookup table is searched with variables of type code}
            begin
              LookLinesRec."Lower Amount" := 0;
              LookLinesRec."Lower Code" := CurrLineRec."E/D Code";
               LookLinesRec.SetRange("Upper Amount",0);
               LookLinesRec.SetRange("Lower Amount",0);
            end
          end; { Case}

          case LookHeaderRec.Type of
          0,1: begin
             { Extract amount as follows; First find line where Lower Amount or
               Lower Code is just greater than the CurrLineRec then move one line
               back.}

            if  LookLinesRec.Find( '=') then
              ReturnAmount := LookLinesRec."Extract Amount"
            else
            if  LookLinesRec.Find( '>') then
            begin
              BackOneRec :=  LookLinesRec.Next( -1);
              ReturnAmount := LookLinesRec."Extract Amount";
            end
            else
              if LookHeaderRec.Type = 0 then begin
                {CurrLineRec.Amount is > than the table's greatest "Lower amount"}
                if  LookLinesRec.Find( '+') then
                  ReturnAmount := LookLinesRec."Extract Amount"
                else
                  exit (LineToChangeRec.Amount)
              end
              else
                {CurrLineRec.EDCode is > than the table's greatest "Lower code"}
                exit (LineToChangeRec.Amount);
            end;

          2: {  Extract amount from tax table}
            ReturnAmount := (CalcTaxAmt (LookLinesRec, CurrLineRec.Amount *
                                         LookHeaderRec."Input Factor")) *
                            LookHeaderRec."Output Factor";
          end; { Case }

          { Adjust the amount as per the maximum/minimum in the LookupHeader}
          if (LookHeaderRec."Max. Extract Amount" <> 0) and
             (ReturnAmount > LookHeaderRec."Max. Extract Amount") then
            ReturnAmount := LookHeaderRec."Max. Extract Amount"
          else
            if (ReturnAmount < LookHeaderRec."Min. Extract Amount") then
              ReturnAmount := LookHeaderRec."Min. Extract Amount";

          { Check for rounding }
          if LookHeaderRec."Rounding Precision" = 0 then
            RoundPrec := 0.01
          else
            RoundPrec := LookHeaderRec."Rounding Precision";
          case LookHeaderRec."Rounding Direction" of
            1: RoundDir := '>';
            2: RoundDir := '<';
            else RoundDir := '=';
          end;
          ReturnAmount := Round (ReturnAmount, RoundPrec, RoundDir);

           LookLinesRec.Reset
        end;


      { Adjust amount as per maximum/minimum set in the E/D file. This will overide
        any max/min. values set in the Table Lookup Header file}
      ReturnAmount := ChkRoundMaxMin (EDFileRec, ReturnAmount);

      exit (ReturnAmount);
    END;

    [LineStart(117535)]
    PROCEDURE ChangeAllOver@10(CurrentRec@1000000000 : Record "Monthly Variables Lines.";CurrWasDeleted@1000000001 : Boolean);
    BEGIN
      {��������������������������������������������������������������������������Ŀ
      � Go through all the lines and where a line is supposed to Change others    �
      � then change those others.                                                 �
      � Parameters :                                                              �
      �   CurrentRec      : Current Entry line                                    �
      �   CurrWasDeleted  : True if the current record was deleted                �
      ����������������������������������������������������������������������������}

      ChangeOthersRec := CurrentRec;
       ChangeOthersRec.SetRange("Payroll Period", CurrentRec."Payroll Period");
       ChangeOthersRec.SetRange("Employee No", CurrentRec."Employee No");
       ChangeOthersRec.SetRange(ChangeOthers, true);

      ChangeOthersRec."E/D Code" := '';
      if not  ChangeOthersRec.Find( '>') then
        exit;

      {Set the maximum number of times the Amount can be changed for any one line.
       This will be used to ensure that this function does not execute 'forever',
       when the user has defined 'cyclic' E/Ds}
      MaxChangeCount := 50;

      repeat

        { Process the record to change others only if it isn't the deleted one }
        if not (CurrWasDeleted and (ChangeOthersRec."E/D Code" =
                                    CurrentRec."E/D Code"))
        then begin
          ComputeAgain (ChangeOthersRec, CurrentRec, CurrWasDeleted);
          CalcFactorAgain (ChangeOthersRec, CurrentRec, CurrWasDeleted);
        end;
        ChangeOthersRec.ChangeOthers := false;
        ChangeOthersRec.ChangeCounter := ChangeOthersRec.ChangeCounter + 1;
         ChangeOthersRec.Modify;
        ProllRecStore := ChangeOthersRec;
        ChangeOthersRec."E/D Code" := '';
      until ((ProllRecStore.ChangeCounter > MaxChangeCount) or
             ( ChangeOthersRec.Next(1) = 0));
      Commit;
       ChangeOthersRec.SetRange("Payroll Period");
       ChangeOthersRec.SetRange("Employee No");
       ChangeOthersRec.SetRange(ChangeOthers);

      if (ProllRecStore.ChangeCounter > MaxChangeCount) then
        Message ('The E/D Code %1, / seems to have been defined with CYCLIC' +
                 ' characteristics', ProllRecStore."E/D Code");

      exit;
    END;

    [LineStart(117585)]
    PROCEDURE ComputeAgain@11(ParamLine@1000000000 : Record "Monthly Variables Lines.";CurrentRec@1000000001 : Record "Monthly Variables Lines.";CurrWasDeleted@1000000002 : Boolean);
    BEGIN
      {��������������������������������������������������������������������������Ŀ
      � Compute values for the E/D specified in the Compute field for the         �
      �  Entry Line record passed as a parameter                                  �
      � Parameters :                                                              �
      �   ParamLine       : Entry line passed as a parameter                      �
      �   CurrentRec      : Current Entry line                                    �
      �   CurrWasDeleted  : True if the current record was deleted                �
      ����������������������������������������������������������������������������}

       ConstEDFileRec.Get( ParamLine."E/D Code");
      "E/DFileRec" := ConstEDFileRec;
      if "E/DFileRec".Compute = '' then
        exit;

       ProllEntryRec.Reset;
       ProllEntryRec.Init;
       ProllEntryRec.SetRange("Payroll Period", CurrentRec."Payroll Period");
       ProllEntryRec.SetRange("Employee No", CurrentRec."Employee No");

      { If the entry line to be computed does not exist then EXIT }
      ProllEntryRec := ParamLine;
      ProllEntryRec."E/D Code" := ConstEDFileRec.Compute;
      if not  ProllEntryRec.Find( '=') then
        exit;

      { If CurrentRec is to be deleted, then no need to re-compute it }
      if (CurrWasDeleted and (ProllEntryRec."E/D Code" = CurrentRec."E/D Code"))
      then exit;

      {
        Initialise the variable to store the computed total. If a record was
        deleted then initialise to 0. Otherwise if the current line (i.e that
        entered by the user) also contributes to the computed line then we
        initialise the computed total to that amount
      }
       "E/DFileRec".Get( CurrentRec."E/D Code");
      if CurrWasDeleted then
        ComputedTotal := 0
      else
       if "E/DFileRec".Compute = ConstEDFileRec.Compute then begin
         if "E/DFileRec"."Add/Subtract" = 2 then
          { Subtract }
          ComputedTotal := -  CurrentRec.Amount
         else
          { Add }
          ComputedTotal := CurrentRec.Amount;
       end
       else
        ComputedTotal := 0;

      {Get first record in P.Roll Entry file for this Employee group}
      ProllEntryRec := ParamLine;
      ProllEntryRec."E/D Code" := '';
       ProllEntryRec.Find( '>');

      { Go through all the entry lines for this Employee group and sum up
        all those that contribute to the E/D specified in the Compute field for
        the current entry line }
      repeat

        if ProllEntryRec."E/D Code" <> CurrentRec."E/D Code" then begin

           "E/DFileRec".Get( ProllEntryRec."E/D Code");
          if "E/DFileRec".Compute = ConstEDFileRec.Compute then
            if "E/DFileRec"."Add/Subtract" = 2 then
              { Subtract }
              ComputedTotal := ComputedTotal - ProllEntryRec.Amount
            else
              { Add }
              ComputedTotal := ComputedTotal + ProllEntryRec.Amount

        end
      until ( ProllEntryRec.Next(1) = 0);

      { Move the computed amount to the line whose E/D Code is the one that has
        just been calculated.}
       ProllEntryRec.Init;
      ProllEntryRec."E/D Code" := ConstEDFileRec.Compute;
       "E/DFileRec".Get( ConstEDFileRec.Compute);
      {dbTRANSFERFIELDS ("E/DFileRec", ProllEntryRec);}

      {Check for rounding, Maximum and minimum }
      ComputedTotal := ChkRoundMaxMin ("E/DFileRec", ComputedTotal);

      {ProllEntryRec.Amount := ComputedTotal;
      ProllRecStore := ProllEntryRec;}

       ProllEntryRec.LockTable( false);
      if  ProllEntryRec.Find( '=') then
      begin
        {FactorRecAmount := ProllEntryRec.Amount;}
        {ProllEntryRec := ProllRecStore;}

        {The new entry in this line should now be used to Compute another and
         also entries where it is a Factor, therefore set ChangeOthers to True}
        if ProllEntryRec.Amount <> ComputedTotal then
        begin
          ProllEntryRec.Amount := ComputedTotal;
          ProllEntryRec.ChangeOthers := true;
           ProllEntryRec.Modify
        end
      end;
      Commit;

       ProllEntryRec.Reset;
    END;

    [LineStart(117692)]
    PROCEDURE CalcFactorAgain@12(ParamLine@1000000000 : Record "Monthly Variables Lines.";CurrentRec@1000000001 : Record "Monthly Variables Lines.";CurrWasDeleted@1000000002 : Boolean);
    BEGIN
      {���������������������������������������������������������������������������Ŀ
      � If a change in a line due to the entry or change to another entry is a     �
      � contributory factor for the value of another line, then  compute that      �
      �other line's value and insert it appropriately                              �
      � Parameters :                                                               �
      �   ParamLine         : Line whose value should change others                �
      �   CurrentRec        : Current Entry line                                   �
      �   CurrWasDeleted    : True if CurrentRec is to be deleted                  �
      �����������������������������������������������������������������������������}

      {Get first record in Employee Group Lines file for this Employee group}
       ProllEntryRec.Reset;
       ProllEntryRec.Init;
       ProllEntryRec.SetRange("Payroll Period", ParamLine."Payroll Period");
       ProllEntryRec.SetRange("Employee No", ParamLine."Employee No");
      ProllEntryRec := ParamLine;
      ProllEntryRec."E/D Code" := '';
      if not  ProllEntryRec.Find( '>') then
        exit;

      { Go through all the entry lines for this Employee Group record and where
        the current entry line's value is a factor, calculate that amount. }
      repeat

         "E/DFileRec".Get( ProllEntryRec."E/D Code");

        if "E/DFileRec"."Factor Of" = ParamLine."E/D Code" then
        begin

          FactorRecAmount := ProllEntryRec.Amount;
          if (CurrWasDeleted and (ParamLine."E/D Code" = CurrentRec."E/D Code"))
          then
            ProllEntryRec.Amount := 0
          else
            ProllEntryRec.Amount := "CalcFactor1.1" (ParamLine, ProllEntryRec,
                                                     "E/DFileRec");

          {The new entry in this line should now be used to Compute another and
           also entries where it is a Factor, therefore set ChangeOthers to True}
          if FactorRecAmount <> ProllEntryRec.Amount then
          begin
            ProllEntryRec.ChangeOthers := true;
             ProllEntryRec.Modify
          end
        end;

      until ( ProllEntryRec.Next(1) = 0);
      Commit;

       ProllEntryRec.Reset;
    END;

    [LineStart(117744)]
    PROCEDURE ResetChangeFlags@13(CurrentRec@1000000000 : Record "Monthly Variables Lines.");
    BEGIN
      {���������������������������������������������������������������������������Ŀ
      � Reset ChangeOthers to false for all lines in this Period/Employee          �
      � Parameters :                                                               �
      �   CurrentRec  : Current entry line                                         �
      �����������������������������������������������������������������������������}
      {Get first record in Employee Group Lines file for this Employee group}
      ProllEntryRec := CurrentRec;
       ProllEntryRec.Init;
       ProllEntryRec.SetRange("Payroll Period", CurrentRec."Payroll Period");
       ProllEntryRec.SetRange("Employee No", CurrentRec."Employee No");
      ProllEntryRec."E/D Code" := '';
       ProllEntryRec.Find( '>');

      { Reset ChangeOthers for this Employee Group }
      repeat

        ProllEntryRec.ChangeOthers   := false;
        ChangeOthersRec.ChangeCounter := 0;
      {BDC - Do not modify the one to be deleted}
        if ProllEntryRec."E/D Code" <> CurrentRec."E/D Code" then
         ProllEntryRec.Modify;

      until ( ProllEntryRec.Next(1) = 0);
      Commit;

       ProllEntryRec.Reset;
    END;

    [LineStart(117772)]
    PROCEDURE AmountIsComputed@8(VAR ReturnAmount@1000000000 : Decimal;EntryLineRec@1000000001 : Record "Monthly Variables Lines.";EDFileRec@1000000002 : Record "Payroll-E/D Codes.";NewAmount@1000000003 : Decimal;EDCode@1000000004 : Code[20]) : Boolean;
    BEGIN
      {��������������������������������������������������������������������������Ŀ
      � Check for values that should COMPUTE the amount for the P.Roll Entry      �
      � Line record.                                                              �
      � Return:                                                                   �
      �   If there are entries for the employee/period that compute the value     �
      �   then return TRUE else return FALSE                                      �
      � Parameters :                                                              �
      �   ReturnAmount:  The computed amount, by refference                       �
      �   EntryLineRec:  The P.Roll Entry record whose value is to be computed    �
      �   EDFileRec   :  The E/D file record of the E/D of the P.Roll Entry Record�
      �   NewAmount   :  The new calculated or entered amount in the current rec. �
      ����������������������������������������������������������������������������}

      ProllRecStore := EntryLineRec;

      {Get first record in P.Roll Entry file for this Period/Employee combination}
       ProllRecStore.SetRange("Payroll Period", EntryLineRec."Payroll Period");
       ProllRecStore.SetRange("Employee No", EntryLineRec."Employee No");
      ProllRecStore."E/D Code" := '';
      if not  ProllRecStore.Find( '>') then
        exit (false);

      { Initialise the variable to store the computed total. }
      ReturnAmount := 0;
      IsComputed := false;

      { Go through all the entry lines for this Period/Employee record and sum up
        all those that contribute to the E/D of the given payroll entry line }
      repeat
         "E/DFileRec".Get( ProllRecStore."E/D Code");
        if "E/DFileRec".Compute = EntryLineRec."E/D Code" then begin
      {BDC
          IF  ProllRecStore.MARK THEN
        }
          if  ProllRecStore."E/D Code" = EDCode then
            AmtToAdd := NewAmount
          else
            AmtToAdd := ProllRecStore.Amount;

          if "E/DFileRec"."Add/Subtract" = 2 then
            { Subtract }
            ReturnAmount := ReturnAmount - AmtToAdd
          else
            { Add }
            ReturnAmount := ReturnAmount + AmtToAdd;

          IsComputed := true
        end
      until ( ProllRecStore.Next(1) = 0);

      exit (IsComputed);
    END;

    [LineStart(117825)]
    PROCEDURE ChangeDueToDelete@6(DeletedRec@1000000000 : Record "Monthly Variables Lines.");
    BEGIN
      {��������������������������������������������������������������������������Ŀ
      � Due to the deleted record, ensure all the other lines are correct.        �
      � Parameters :                                                              �
      �   DeletedRec : The current record (= the record to be deleted)            �
      �                                                                           �
      ����������������������������������������������������������������������������}
      {Get first record in Employee Group Lines file for this Employee group}
      ProllEntryRec := DeletedRec;
       ProllEntryRec.SetRange("Payroll Period", DeletedRec."Payroll Period");
       ProllEntryRec.SetRange("Employee No", DeletedRec."Employee No");

      { If the deleted record was 'COMPUTING' another then make changes }
       "E/DFileRec".Get( DeletedRec."E/D Code");
      ProllEntryRec."E/D Code" := "E/DFileRec".Compute;
      if  ProllEntryRec.Find( '=') then
        ComputeAgain (DeletedRec, DeletedRec, true);

      { If another record is a 'FACTOR OF' the deleted one then make changes }
      CalcFactorAgain (DeletedRec, DeletedRec, true);

      { Due to these changes adjust AMOUNTS in all lines }
      ChangeAllOver (DeletedRec, true);
      exit;
    END;

    [LineStart(117850)]
    PROCEDURE ChkRoundMaxMin@14(EDRecord@1000000000 : Record "Payroll-E/D Codes.";TheAmount@1000000001 : Decimal) : Decimal;
    BEGIN
      {��������������������������������������������������������������������������Ŀ
      � Round an amount and check for Max and Min. Return the amended amount.     �
      � Parameters :                                                              �
      �   EDRecord : The ED file record to use to check Round, Max. and Min       �
      �   TheAmount: The amounht to Round, and check for Max. and Min             �
      ����������������������������������������������������������������������������}

      { Adjust amount as per maximum/minimum set in the E/D file. }
      if (EDRecord."Max. Amount" <> 0) and
         (TheAmount > EDRecord."Max. Amount") then
        TheAmount := EDRecord."Max. Amount"
      else
        if TheAmount < EDRecord."Min. Amount" then
          TheAmount := EDRecord."Min. Amount";

      { Check for rounding }
      if EDRecord."Rounding Precision" = 0 then
        RoundPrec := 0.01
      else
        RoundPrec := EDRecord."Rounding Precision";
      case EDRecord."Rounding Direction" of
        1: RoundDir := '>';
        2: RoundDir := '<';
        else RoundDir := '=';
      end;
      TheAmount := Round (TheAmount, RoundPrec, RoundDir);

      exit (TheAmount);
    END;

    [LineStart(117880)]
    PROCEDURE GetParam@15();
    BEGIN
      PaySetup.Reset;
      PaySetup.Find('-');
      DaysInMonth := PaySetup."Monthly Working Days";
      HrsInDay := PaySetup."Daily Working Hours";

      if ("Employee No" <>'') then BasicPay := EmployeeRec.GetBasic("Employee No");
      //MESSAGE('Basic Pay is %1',BasicPay);
    END;

    BEGIN
    END.
  }
}

